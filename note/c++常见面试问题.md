## C语言和C++有什么区别
c语言是面向过程的语言，重点在算法和数据结构的使用，应用在计算机底层
而C++是面向对象的语言，主要是类、继承、封装

主要区别为类、继承、运算符重载、泛型编程和stl, 模板库，类型安全的功能（强制类型转换）

## struct和class有什么区别
1.成员默认权限不同，class默认是private，struct默认是公有
2.默认继承权限不同，class继承是private，struct默认是公有
3.class可以用于定义模板参数，作用同typename, 但关键字struct不能定义模板参数
4.struct一般用于存储结构化数据，保留struct是为了向下兼容，

## 函数重载和覆盖有什么区别
重载：同一范围，函数名相同，参数不同，virtual可有可无
覆盖：不同范围，函数名一样，参数相同，基类函数必须有virtual


## 谈一谈你对多态的理解，运行时多态的实现原理是什么
多态是一个接口具有不同的行为，包含编译时多态和运行时多态，其中编译时多态是使用函数重载实现
而运行时多态是通过继承和虚函数实现。
其原理是编译时为每个类创建一虚函数表和虚函数指针，虚函数指针指向虚函数表，虚函数表中存储虚函数的地址。程序运行时，会根据对象的实际类型来初始化虚表指针，指向所属类的虚表。子类继承父类也会继承父类的虚函数表，当子类重写父类的虚函数时，会将其继承到的虚函数表中的地址替换成重新写的地址。进而在调用虚函数时，可以根据函数地址找到正确的函数。



## 如果虚函数是有效的，那为什么不把所有函数设为虚函数？
关于构造函数和析构函数不能设为虚函数见（6）
使用虚函数，会增加访问内存开销，降低效率。虚函数表时每个对象实例共享的，但虚函数指针是每个对象实例都有一个。
C++提倡高效编程、零开销和对硬件的直接访问。

## 构造函数可以是虚函数吗？析构函数可以是虚函数吗？
构造函数不可以，虚函数是通过虚函数指针来调用的，可以对象还没有实例化，即没有内存空间，没有虚指针
析构函数可以，当使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则会存在内存泄漏的问题.

## 基类的析构函数可以调用虚函数吗？基类的构造函数可以调用虚函数吗？
可以调用，但是往往不饿能达到需要的目的（不能实现多态）。因为调用构造函数的时候，先进行父类成分的构造，再进行子类的构造。在父类构造构造期间，子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经被销毁，此时是无法调用虚函数实现多态

##  C++中四个强制类型转换的关键词
1. static_cast：
    static_cast<type-id>(expression) //将expression转换为type-id类型
    缺少运行时类型检查来保证转换的安全性。 
    并且不能转换掉expression的const, volitale或者__unsigned类型

    常用于以下场景
        1. 类层次结构中基类和派生类的指针或引用的转换   
        2. 用于基本类型之间的转换
        3. 把空指针转换成目标类型的空指针
        4. 把任意类型的表达式转换成void形式
2. const_cast 
    const_cast<>里面的内容必须是引用或者指针，
    不能转换基础类型，即使int2int
    C++提供的一种修改const变量形式，没有什么实质性的作用，建议不用
3. reinterpet_cast  
    1.改变指针或引用的类型
    2.将指针或应用转换为一个足够长度的整型
    3.将整型转换未指针或引用的形式
    reinterpret_cast<type_id>(expression)
    其中type-id必须是一个指针、引用、算数类型、函数指针或者成员指针。
    它可以把一个指针（整数）转换成一个整数（指针）需要谨慎使用这个指针。
    我们映射到的类型仅仅是为了故弄玄虚和其他目的，这是所有映射中最危险的。
4. dynamic_cast
    dynamic_cast<type-id>(expression)
    1.其他三种转换类型都是编译时完成的，dynamic_cast是在运行时完成并类型检查
    2.不能用于内置的基本数据类型的强制转换
    3.dynamic_cast要求<>内所描述的目标类型必须为指针或引用，
    转换成功会返回指向类的指针或引用，转换失败的话则返回nullptr
    4.在类的转换时，在类层次间进行上行转换（子类指针指向父类指针）时，
    dynamic_cast和static_cast效果一样。但当下行转换（父类指针转化为子类指针）时，
    dynamic_cast具有类型检查的功能，比static_cast安全。向下转换的成功与否还与
    将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换后的对象类型一定
    要相同，否则转换失败。C++编译时的类型转换有可能会在运行时发生错误，特别是
    涉及到类对象的指针或引用操作时，更容易发生错误，而dynamic_cast操作符可以在运行
    时对可能产生的问题类型转换进行测试。
    5.使用dynamic_cast进行转换，基类中一定要有虚函数，否则编译不通过（类中有虚函数，
    就说明它有想让基类指针或引用指向派生类对象的情况，此时转换才有意义）。这是由于
    运行时类型检查需要运行时类型信息，这个信息存储在类的虚函数表中，只有定义了虚函数
    的类才有虚函数表